using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Linq;

namespace luadec.IR
{
    /// <summary>
    /// A Lua function. A function contains a CFG, a list of instructions, and child functions used for closures
    /// </summary>
    public class Function
    {
        private List<Identifier> Parameters;
        private List<Function> Closures;
        private List<IInstruction> Instructions;

        private Dictionary<uint, Label> Labels;

        /// <summary>
        /// Set to true when this is converted to a CFG
        /// </summary>
        private bool IsControlFlowGraph = false;

        /// <summary>
        /// When the CFG has been converted to an AST
        /// </summary>
        private bool IsAST = false;

        /// <summary>
        /// The first basic block in which control flow enters upon the function being called
        /// </summary>
        private CFG.BasicBlock BeginBlock;

        /// <summary>
        /// The final (empty) basic block that is the successor to the end of the function and any blocks that end with a return instruction
        /// </summary>
        private CFG.BasicBlock EndBlock;

        /// <summary>
        /// List of all the blocks for some analyses
        /// </summary>
        private List<CFG.BasicBlock> BlockList;

        /// <summary>
        /// Identifiers that are used in more than one basic block
        /// </summary>
        private HashSet<Identifier> GlobalIdentifiers;

        private static int IndentLevel = 0;

        public static int DebugIDCounter = 0;
        public int DebugID = 0;

        public Function()
        {
            Parameters = new List<Identifier>();
            Closures = new List<Function>();
            Instructions = new List<IInstruction>();
            Labels = new Dictionary<uint, Label>();
            BlockList = new List<CFG.BasicBlock>();
            GlobalIdentifiers = new HashSet<Identifier>();
            DebugID = DebugIDCounter;
            DebugIDCounter++;
        }

        public void AddInstruction(IInstruction inst)
        {
            Instructions.Add(inst);
        }

        public void AddClosure(Function fun)
        {
            Closures.Add(fun);
        }

        public Function LookupClosure(uint i)
        {
            return Closures[(int)i];
        }

        public void SetParameters(List<Identifier> parameters)
        {
            Parameters = parameters;
        }

        public Label GetLabel(uint pc)
        {
            if (Labels.ContainsKey(pc))
            {
                Labels[pc].UsageCount++;
                return Labels[pc];
            }
            var label = new Label();
            label.OpLocation = (int)pc;
            label.UsageCount = 1;
            Labels.Add(pc, label);
            return label;
        }

        /// <summary>
        /// Call after a function's IR is generated to actually insert the labels into the instruction stream
        /// </summary>
        public void ApplyLabels()
        {
            // O(n^2) naive algorithm so sue me
            foreach (var l in Labels)
            {
                for (int i = 0; i < Instructions.Count(); i++)
                {
                    if (Instructions[i].OpLocation == l.Key)
                    {
                        Instructions.Insert(i, l.Value);
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Super simple analysis that eliminates assignments of the form:
        /// REGA = REGA
        /// 
        /// These are often generated by the TEST instruction and elimination of these simplifies things for future passes
        /// </summary>
        public void EliminateRedundantAssignments()
        {
            for (int i = 0; i < Instructions.Count(); i++)
            {
                if (Instructions[i] is Assignment assn && assn.Left.Count() == 1 && !assn.Left[0].HasIndex)
                {
                    if (assn.Right is IdentifierReference reference && !reference.HasIndex && assn.Left[0].Identifier == reference.Identifier)
                    {
                        Instructions.RemoveAt(i);
                        i--;
                    }
                }
            }
        }
        
        /// <summary>
        /// Simple analysis pass to recognize lua conditional jumping patterns and merge them into a single instruction
        /// </summary>
        public void MergeConditionalJumps()
        {
            // Lua conditional jumps often follow this pattern when naively translated into the IR:
            //   if REGA == b then goto Label_1:
            //   goto Label_2:
            //   Label_1:
            //   ...
            //
            // This pass recognizes and simplifies this into:
            //   if REGA ~= b then goto Label_2:
            //   ...
            //
            // This will greatly simplify the generated control flow graph, so this is done first
            // This algorithm is run until convergence
            int instanceCounts = 1;
            while (instanceCounts > 0)
            {
                instanceCounts = 0;
                for (int i = 0; i < Instructions.Count() - 2; i++)
                {
                    // Pattern match the prerequisites
                    if (Instructions[i] is Jump jmp1 && jmp1.Conditional &&
                        Instructions[i + 1] is Jump jmp2 && !jmp2.Conditional &&
                        Instructions[i + 2] is Label shortLabel && jmp1.Dest == shortLabel)
                    {
                        // flip the condition and change the destination to the far jump. Then remove the following goto and label
                        if (jmp1.Condition is BinOp op)
                        {
                            op.NegateCondition();
                            jmp1.Dest.UsageCount--;
                            Instructions.RemoveRange(i + 1, jmp1.Dest.UsageCount <= 0 ? 2 : 1);
                            jmp1.Dest = jmp2.Dest;
                            instanceCounts++;
                        }
                        else
                        {
                            throw new Exception("Recognized jump pattern does not use a binary op conditional");
                        }
                    }
                }
            }
        }

        public void MergeConditionalAssignments()
        {
            // Sometimes a conditional assignment is generated in lua to implement something like:
            // local var = somefunction() == true
            //
            // This would generate the following IR:
            // if REGA == 1234 else goto label_1
            // REGB = false
            // goto label_2
            // label_1:
            // REGB = true
            // label_2:
            // ...
            // This pattern matches such a case and replaces it with just:
            // REGB = REGA ~= 1234
            for (int i = 0; i < Instructions.Count() - 6; i++)
            {
                // Big pattern match
                if (Instructions[i] is Jump jmp && jmp.Conditional &&
                    Instructions[i + 1] is Assignment asscond1 && asscond1.Left.Count() == 1 && asscond1.Left[0] is IdentifierReference assignee && 
                    asscond1.Right is Constant c1 && c1.ConstType == Constant.ConstantType.ConstBool && !c1.Boolean &&
                    Instructions[i + 2] is Jump jmp2 && !jmp2.Conditional &&
                    Instructions[i + 3] is Label label1 && label1 == jmp.Dest &&
                    Instructions[i + 4] is Assignment asscond2 && asscond2.Left.Count() == 1 && asscond2.Left[0] is IdentifierReference assignee2 && 
                    assignee.Identifier == assignee2.Identifier && asscond2.Right is Constant c2 && c2.ConstType == Constant.ConstantType.ConstBool && c2.Boolean &&
                    Instructions[i + 5] is Label label2 && label2 == jmp2.Dest)
                {
                    if (jmp.Condition is BinOp bop)
                    {
                        bop.NegateCondition();
                    }
                    var newassn = new Assignment(assignee, jmp.Condition);
                    Instructions[i] = newassn;
                    Instructions.RemoveRange(i + 1, 5);
                }
            }
        }

        public void PeepholeOptimize()
        {
            // Optimizes out jumps to jumps, and deletes labels too if they become unused as a result
            for (int i = 0; i < Instructions.Count(); i++)
            {
                if (Instructions[i] is Jump jmp1)
                {
                    IInstruction dest = Instructions[Instructions.IndexOf(jmp1.Dest) + 1];
                    while (dest is Jump jmp2 && !jmp2.Conditional)
                    {
                        jmp1.Dest.UsageCount--;
                        if (jmp1.Dest.UsageCount <= 0)
                        {
                            Instructions.Remove(jmp1.Dest);
                        }
                        jmp1.Dest = jmp2.Dest;
                        dest = Instructions[Instructions.IndexOf(jmp1.Dest) + 1];
                    }
                }
            }
        }

        // Validates control flow integrity of the function (every jump destination label exists)
        public void CheckControlFlowIntegrity()
        {
            for (int i = 0; i < Instructions.Count(); i++)
            {
                if (Instructions[i] is Jump jmp)
                {
                    if (Instructions.IndexOf(jmp.Dest) == -1)
                    {
                        throw new Exception("Control flow is corrupted");
                    }
                }
            }
        }

        /// <summary>
        /// Transforms the current function into a control flow graph. This will break the function as a linear set of instructions
        /// </summary>
        public void ConstructControlFlowGraph()
        {
            IsControlFlowGraph = true;

            // Create the begin and end basic blocks
            CFG.BasicBlock.ResetCounter();
            BeginBlock = new CFG.BasicBlock();
            EndBlock = new CFG.BasicBlock();
            BlockList.Add(BeginBlock);

            // These are used to connect jmps to their destinations later
            var labelBasicBlockMap = new Dictionary<Label, CFG.BasicBlock>();

            // First pass: Build all the basic blocks using labels, jmps, and rets as boundries
            var currentBlock = BeginBlock;
            for (int i = 0; i < Instructions.Count(); i++)
            {
                // Unconditional jumps just start a new basic block
                if (Instructions[i] is Jump jmp && !jmp.Conditional)
                {
                    currentBlock.Instructions.Add(jmp);
                    jmp.Block = currentBlock;
                    currentBlock = new CFG.BasicBlock();
                    BlockList.Add(currentBlock);
                    if (i + 1 < Instructions.Count() && Instructions[i+1] is Label l)
                    {
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }
                }
                // Conditional jumps has the following block as a successor
                else if (Instructions[i] is Jump jmp2 && jmp2.Conditional)
                {
                    currentBlock.Instructions.Add(jmp2);
                    jmp2.Block = currentBlock;
                    var newBlock = new CFG.BasicBlock();
                    currentBlock.Successors.Add(newBlock);
                    newBlock.Predecessors.Add(currentBlock);
                    currentBlock = newBlock;
                    BlockList.Add(currentBlock);
                    if (i + 1 < Instructions.Count() && Instructions[i + 1] is Label l)
                    {
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }
                }
                // Returns simply go directly to the end block, and starts a new basic block if not at the end
                else if (Instructions[i] is Return ret)
                {
                    currentBlock.Instructions.Add(ret);
                    ret.Block = currentBlock;
                    currentBlock.Successors.Add(EndBlock);
                    EndBlock.Predecessors.Add(currentBlock);
                    if (i + 1 < Instructions.Count())
                    {
                        currentBlock = new CFG.BasicBlock();
                        BlockList.Add(currentBlock);
                    }
                    if (i + 1 < Instructions.Count() && Instructions[i + 1] is Label l)
                    {
                        labelBasicBlockMap.Add(l, currentBlock);
                        i++;
                    }
                }
                // Other labels just start a new fallthrough basic block
                else if (Instructions[i] is Label l2)
                {
                    var newBlock = new CFG.BasicBlock();
                    currentBlock.Successors.Add(newBlock);
                    newBlock.Predecessors.Add(currentBlock);
                    currentBlock = newBlock;
                    BlockList.Add(currentBlock);
                    labelBasicBlockMap.Add(l2, currentBlock);
                }
                // Otherwise add instruction to the block
                else
                {
                    currentBlock.Instructions.Add(Instructions[i]);
                    Instructions[i].Block = currentBlock;
                }
            }

            // Second pass: Connect jumps to their basic blocks
            for (int b = 0; b < BlockList.Count(); b++)
            {
                if (BlockList[b].Instructions.Count() > 0 && BlockList[b].Instructions.Last() is Jump jmp)
                {
                    BlockList[b].Successors.Add(labelBasicBlockMap[jmp.Dest]);
                    labelBasicBlockMap[jmp.Dest].Predecessors.Add(BlockList[b]);
                    jmp.BBDest = labelBasicBlockMap[jmp.Dest];
                }
            }

            // Third pass: Remove unreachable blocks
            for (int b = 0; b < BlockList.Count(); b++)
            {
                // Begin block has no predecessors but shouldn't be removed because :)
                if (BlockList[b] == BeginBlock)
                {
                    continue;
                }
                if (BlockList[b].Predecessors.Count() == 0)
                {
                    foreach (var succ in BlockList[b].Successors)
                    {
                        succ.Predecessors.Remove(BlockList[b]);
                    }
                    BlockList.RemoveAt(b);
                    b--;
                }
            }

            // Dangling no successor blocks should go to the end block (implicit return)
            for (int b = 0; b < BlockList.Count(); b++)
            {
                if (BlockList[b] == EndBlock)
                {
                    continue;
                }
                if (BlockList[b].Successors.Count() == 0)
                {
                    BlockList[b].Successors.Add(EndBlock);
                }
            }

            BlockList.Add(EndBlock);
        }

        /// <summary>
        /// Resolves function calls that have 0 as its "b", which means the actual arguments are determined by a
        /// previous function with an indefinite return count being the last argument
        /// </summary>
        /// <param name="table"></param>
        public void ResolveIndeterminantArguments(SymbolTable table)
        {
            // This analysis should not need any intrablock analysis
            foreach (var b in BlockList)
            {
                Identifier lastIndeterminantRet = null;
                foreach (var i in b.Instructions)
                {
                    if (i is Assignment a2 && a2.Right is FunctionCall fc2 && fc2.IsIndeterminantArgumentCount)
                    {
                        if (lastIndeterminantRet == null)
                        {
                            throw new Exception("Error: Indeterminant argument function call without preceding indeterminant return function call");
                        }
                        for (uint r = fc2.BeginArg; r <= lastIndeterminantRet.Regnum; r++)
                        {
                            fc2.Args.Add(new IdentifierReference(table.GetRegister(r)));
                        }
                        lastIndeterminantRet = null;
                    }
                    if (i is Assignment a && a.Left.Count() == 1 && !a.Left[0].HasIndex && a.Right is FunctionCall fc && fc.IsIndeterminantReturnCount)
                    {
                        lastIndeterminantRet = a.Left[0].Identifier;
                    }
                }
            }
        }

        /// <summary>
        /// Computes the dominance sets for all the nodes as well as the dominance tree
        /// </summary>
        private void ComputeDominance()
        {
            // Start block only has itself in dominace set
            BeginBlock.Dominance.Clear();
            BeginBlock.DominanceTreeSuccessors.Clear();
            BeginBlock.Dominance.Add(BeginBlock);

            // All blocks but the start have everything dominate them to begin the algorithm
            for (int i = 1; i < BlockList.Count(); i++)
            {
                BlockList[i].Dominance = new HashSet<CFG.BasicBlock>(BlockList);
                BlockList[i].DominanceTreeSuccessors.Clear();
            }

            // Iterative solver of dominance data flow equation
            bool changed = true;
            while (changed)
            {
                changed = false;
                for (int i = 1; i < BlockList.Count(); i++)
                {
                    var temp = new HashSet<CFG.BasicBlock>(BlockList);
                    foreach (var p in BlockList[i].Predecessors)
                    {
                        temp.IntersectWith(p.Dominance);
                    }
                    temp.UnionWith(new[] { BlockList[i] });
                    if (!temp.SetEquals(BlockList[i].Dominance))
                    {
                        BlockList[i].Dominance = temp;
                        changed = true;
                    }
                }
            }

            // Compute the immediate dominator
            for (int i = 1; i < BlockList.Count(); i++)
            {
                BlockList[i].ComputeImmediateDominator();
            }
        }

        private void ComputeDominanceFrontier()
        {
            for (int i = 0; i < BlockList.Count(); i++)
            {
                if (BlockList[i].Predecessors.Count() > 1)
                {
                    foreach (var p in BlockList[i].Predecessors)
                    {
                        var runner = p;
                        while (runner != BlockList[i].ImmediateDominator)
                        {
                            runner.DominanceFrontier.UnionWith(new[] { BlockList[i] });
                            runner = runner.ImmediateDominator;
                        }
                    }
                }
            }
        }

        private void ComputeGlobalLiveness(HashSet<Identifier> allRegisters)
        {
            foreach (var b in BlockList)
            {
                GlobalIdentifiers.UnionWith(b.ComputeKilledAndUpwardExposed());
            }

            // Compute live out for each block iteratively
            bool changed = true;
            while (changed)
            {
                changed = false;
                foreach (var b in BlockList)
                {
                    var temp = new HashSet<Identifier>();
                    foreach (var succ in b.Successors)
                    {
                        var equation = new HashSet<Identifier>(allRegisters);
                        foreach (var kill in succ.KilledIdentifiers)
                        {
                            equation.Remove(kill);
                        }
                        equation.IntersectWith(succ.LiveOut);
                        equation.UnionWith(succ.UpwardExposedIdentifiers);
                        temp.UnionWith(equation);
                    }
                    if (!b.LiveOut.SetEquals(temp))
                    {
                        b.LiveOut = temp;
                        changed = true;
                    }
                }
            }
        }

        public void ConvertToSSA(HashSet<Identifier> allRegisters)
        {
            allRegisters.UnionWith(Parameters.ToHashSet());
            ComputeDominance();
            ComputeDominanceFrontier();
            ComputeGlobalLiveness(allRegisters);

            // Now insert all the needed phi functions
            foreach (var g in GlobalIdentifiers)
            {
                var work = new Queue<CFG.BasicBlock>();
                var visitedSet = new HashSet<CFG.BasicBlock>();
                foreach (var b in BlockList)
                {
                    if (b != EndBlock && b.KilledIdentifiers.Contains(g))
                    {
                        work.Enqueue(b);
                        visitedSet.Add(b);
                    }
                }
                while (work.Count() > 0)
                {
                    var b = work.Dequeue();
                    foreach (var d in b.DominanceFrontier)
                    {
                        if (d != EndBlock && !d.PhiFunctions.ContainsKey(g))
                        {
                            // Heuristic: if the block is just a single return, we don't need phi functions
                            if (d.Instructions.First() is Return)
                            {
                                continue;
                            }

                            var phiargs = new List<Identifier>();
                            for (int i = 0; i < d.Predecessors.Count(); i++)
                            {
                                phiargs.Add(g);
                            }
                            d.PhiFunctions.Add(g, new PhiFunction(g, phiargs));
                            //if (!visitedSet.Contains(d))
                            //{
                                work.Enqueue(d);
                                visitedSet.Add(d);
                            //}
                        }
                    }
                }
            }

            // Prepare for renaming
            var Counters = new Dictionary<Identifier, int>();
            var Stacks = new Dictionary<Identifier, Stack<Identifier>>();
            foreach (var reg in allRegisters)
            {
                Counters.Add(reg, 0);
                Stacks.Add(reg, new Stack<Identifier>());
            }

            // Creates a new identifier based on an original identifier
            Identifier NewName(Identifier orig)
            {
                var newName = new Identifier();
                newName.Name = orig.Name + $@"_{Counters[orig]}";
                newName.IType = Identifier.IdentifierType.Register;
                newName.OriginalIdentifier = orig;
                Stacks[orig].Push(newName);
                Counters[orig]++;
                return newName;
            }

            void RenameBlock(CFG.BasicBlock b)
            {
                // Rewrite phi function definitions
                foreach (var phi in b.PhiFunctions)
                {
                    phi.Value.RenameDefines(phi.Key, NewName(phi.Key));
                }

                // Rename other instructions
                foreach (var inst in b.Instructions)
                {
                    foreach (var use in inst.GetUses(true))
                    {
                        inst.RenameUses(use, Stacks[use].Peek());
                    }
                    foreach (var def in inst.GetDefines(true))
                    {
                        inst.RenameDefines(def, NewName(def));
                    }
                }

                // Rename successor phi functions
                foreach (var succ in b.Successors)
                {
                    if (succ != EndBlock)
                    {
                        var index = succ.Predecessors.IndexOf(b);
                        foreach (var phi in succ.PhiFunctions)
                        {
                            if (Stacks[phi.Value.Right[index]].Count() > 0)
                            {
                                phi.Value.Right[index] = Stacks[phi.Value.Right[index]].Peek();
                            }
                            else
                            {
                                // Sometimes a phi function is forced when one of the predecessor paths don't actually define the register.
                                // These phi functions are usually not needed and optimized out in a later pass, so we set it to null to detect
                                // errors in case the phi function result is actually used.
                                phi.Value.Right[index] = null;
                            }
                        }
                    }
                }

                // Rename successors in the dominator tree
                foreach (var succ in b.DominanceTreeSuccessors)
                {
                    if (succ != EndBlock)
                    {
                        RenameBlock(succ);
                    }
                }

                // Pop off anything we pushed
                foreach (var phi in b.PhiFunctions)
                {
                    Stacks[phi.Value.Left.OriginalIdentifier].Pop();
                }
                foreach (var inst in b.Instructions)
                {
                    foreach (var def in inst.GetDefines(true))
                    {
                        Stacks[def.OriginalIdentifier].Pop();
                    }
                }
            }

            // Rename the arguments first
            for (int i = 0; i < Parameters.Count(); i++)
            {
                Parameters[i] = NewName(Parameters[i]);
            }

            // Rename everything else recursively
            RenameBlock(BeginBlock);
        }

        // Given the IR is in SSA form, this does expression propogation/substitution
        public void PerformExpressionPropogation()
        {
            bool changed;
            do
            {
                changed = false;
                foreach (var b in BlockList)
                {
                    for (int i = 0; i < b.Instructions.Count(); i++)
                    {
                        var inst = b.Instructions[i];
                        foreach (var use in inst.GetUses(true))
                        {
                            if (use.DefiningInstruction != null && use.DefiningInstruction is Assignment a && a.Left.Count() == 1 && use.UseCount == 1)
                            {
                                bool replaced = inst.ReplaceUses(use, a.Right);
                                if (a.Block != null && replaced)
                                {
                                    changed = true;
                                    a.Block.Instructions.Remove(a);
                                    if (b == a.Block)
                                    {
                                        i--;
                                    }
                                }
                            }
                        }
                    }
                }
            } while (changed);
        }

        public List<CFG.BasicBlock> PostorderTraversal(bool reverse)
        {
            var ret = new List<CFG.BasicBlock>();
            var visited = new HashSet<CFG.BasicBlock>();
            visited.Add(EndBlock);

            void Visit(CFG.BasicBlock b)
            {
                visited.Add(b);
                foreach (var succ in b.Successors)
                {
                    if (!visited.Contains(succ))
                    {
                        Visit(succ);
                    }
                }
                ret.Add(b);
            }

            Visit(BeginBlock);

            if (reverse)
            {
                ret.Reverse();
            }
            return ret;
        }

        private void NumberReversePostorder()
        {
            var ordering = PostorderTraversal(true);
            for (int i = 0; i < ordering.Count(); i++)
            {
                ordering[i].ReversePostorderNumber = i;
            }
        }

        /// <summary>
        /// An assignment is dead if it does not have any subsequent uses. These will be eliminated unless they are a function call.
        /// </summary>
        public void EliminateDeadAssignments(bool phiOnly)
        {
            bool changed = true;
            while (changed)
            {
                changed = false;
                var usageCounts = new Dictionary<Identifier, int>();
                foreach (var arg in Parameters)
                {
                    usageCounts.Add(arg, 0);
                }

                // Do a reverse-postorder traversal to register all the definitions and uses
                foreach (var b in PostorderTraversal(true))
                {
                    // Defines/uses in phi functions
                    foreach (var phi in b.PhiFunctions)
                    {
                        foreach (var use in phi.Value.Right)
                        {
                            if (use != null)
                            {
                                if (!usageCounts.ContainsKey(use))
                                {
                                    usageCounts.Add(use, 0);
                                }
                                usageCounts[use]++;
                            }
                        }
                        if (!usageCounts.ContainsKey(phi.Value.Left))
                        {
                            usageCounts.Add(phi.Value.Left, 0);
                        }
                    }

                    // Defines/uses for everything else
                    foreach (var inst in b.Instructions)
                    {
                        foreach (var use in inst.GetUses(true))
                        {
                            if (!usageCounts.ContainsKey(use))
                            {
                                usageCounts.Add(use, 0);
                            }
                            usageCounts[use]++;
                        }
                        foreach (var def in inst.GetDefines(true))
                        {
                            if (!usageCounts.ContainsKey(def))
                            {
                                usageCounts.Add(def, 0);
                            }
                        }
                    }
                }

                // Do an elimination pass
                foreach (var b in BlockList)
                {
                    // Eliminate unused phi functions
                    var phiToRemove = new List<Identifier>();
                    foreach (var phi in b.PhiFunctions)
                    {
                        if (usageCounts[phi.Value.Left] == 0)
                        {
                            changed = true;
                            phiToRemove.Add(phi.Value.Left);
                        }
                    }
                    phiToRemove.ForEach(x => b.PhiFunctions.Remove(x.OriginalIdentifier));

                    // Eliminate unused assignments
                    var toRemove = new List<IInstruction>();
                    foreach (var inst in b.Instructions)
                    {
                        var defs = inst.GetDefines(true);
                        if (defs.Count() == 1 && usageCounts[defs.First()] == 0)
                        {
                            if (inst is Assignment a && a.Right is FunctionCall)
                            {
                                a.Left.Clear();
                            }
                            else
                            {
                                if (!phiOnly)
                                {
                                    changed = true;
                                    toRemove.Add(inst);
                                }
                            }
                        }
                    }
                    toRemove.ForEach(x => b.Instructions.Remove(x));
                }
            }
        }

        public void DetectLoops()
        {
            // Build an abstract graph to analyze with
            var blockIDMap = new Dictionary<CFG.BasicBlock, int>();
            var abstractNodes = new List<CFG.AbstractGraph.Node>();
            for (int i = 0; i < BlockList.Count(); i++)
            {
                blockIDMap.Add(BlockList[i], i);
                var node = new CFG.AbstractGraph.Node();
                node.OriginalBlock = BlockList[i];
                abstractNodes.Add(node);
            }
            foreach (var b in blockIDMap)
            {
                foreach (var pred in b.Key.Predecessors)
                {
                    abstractNodes[b.Value].Predecessors.Add(abstractNodes[blockIDMap[pred]]);
                }
                foreach (var succ in b.Key.Successors)
                {
                    abstractNodes[b.Value].Successors.Add(abstractNodes[blockIDMap[succ]]);
                }
            }

            // Calculate intervals and the graph sequence in preperation for loop detection
            var headGraph = new CFG.AbstractGraph();
            headGraph.BeginNode = abstractNodes[blockIDMap[BeginBlock]];
            headGraph.Nodes = abstractNodes;
            headGraph.CalculateIntervals();
            headGraph.LabelReversePostorderNumbers();

            var graphSequence = new List<CFG.AbstractGraph>();
            CFG.AbstractGraph childGraph = headGraph;
            while (childGraph != null)
            {
                graphSequence.Add(childGraph);
                foreach (var interval in childGraph.Intervals)
                {
                    // Check if the interval head has a predecessor in the interval that's not already marked as in a loop
                    if (interval.Key.Predecessors.Any(x => interval.Value.Contains(x) && !x.InLoop))
                    {
                        var head = interval.Key;
                        interval.Key.OriginalBlock.IsLoopHead = true;
                        var latch = interval.Key.Predecessors.Where(x => interval.Value.Contains(x)).Max();
                        head.LoopLatch = latch;
                        var loopNodes = new HashSet<CFG.AbstractGraph.Node>();
                        foreach (var l in interval.Value.Where(x => x.ReversePostorderNumber > interval.Key.ReversePostorderNumber && x.ReversePostorderNumber <= latch.ReversePostorderNumber))
                        {
                            loopNodes.Add(l);
                            l.InLoop = true;
                        }

                        // Classify the type of loop
                        if (latch.Successors.Count() == 2)
                        {
                            if (head.Successors.Count() == 2)
                            {
                                if (head.Successors.All(x => loopNodes.Contains(x)))
                                {
                                    head.LoopType = CFG.LoopType.LoopPosttested;
                                }
                                else
                                {
                                    head.LoopType = CFG.LoopType.LoopPretested;
                                }
                            }
                            else
                            {
                                head.LoopType = CFG.LoopType.LoopPosttested;
                            }
                        }
                        else
                        {
                            if (head.Successors.Count() == 2)
                            {
                                head.LoopType = CFG.LoopType.LoopPretested;
                            }
                            else
                            {
                                head.LoopType = CFG.LoopType.LoopEndless;
                            }
                        }
                        head.OriginalBlock.LoopType = head.LoopType;

                        // Find the follow
                        if (head.LoopType == CFG.LoopType.LoopPretested)
                        {
                            head.LoopFollow = head.Successors.First(x => !loopNodes.Contains(x));
                            head.FollowLeader = head;
                        }
                        else if (head.LoopType == CFG.LoopType.LoopPosttested)
                        {
                            head.LoopFollow = latch.Successors.First(x => !loopNodes.Contains(x));
                            head.FollowLeader = latch;
                        }
                        // Infinite loop
                        else
                        {
                            int fol = int.MaxValue;
                            CFG.AbstractGraph.Node follow = null;
                            CFG.AbstractGraph.Node followLeader = null;
                            foreach (var n in loopNodes.Where(x => x.Successors.Count() == 2))
                            {
                                foreach (var succ in n.Successors)
                                {
                                    if (!loopNodes.Contains(succ) && succ.ReversePostorderNumber < fol)
                                    {
                                        fol = succ.ReversePostorderNumber;
                                        follow = succ;
                                        followLeader = n;
                                        break;
                                    }
                                }
                            }
                            if (follow != null)
                            {
                                head.LoopFollow = follow;
                                head.FollowLeader = followLeader;
                            }
                        }
                    }
                }
                childGraph = childGraph.GetIntervalSubgraph();
            }

            // Backpropogate the loop information back to the original graph
            graphSequence.Reverse();
            graphSequence.Remove(headGraph);
            foreach (var graph in graphSequence)
            {
                foreach (var interval in graph.Intervals)
                {
                    // If the interval is a loop head, backpropogate it
                    var head = interval.Key;
                    if (head.LoopLatch != null)
                    {
                        // The latch of the parent is a node that's a predecessor of the parent loop head that belongs to the interval represented by the child node
                        var parentLatch = head.IntervalGraphParent.Predecessors.First(x => head.LoopLatch.IntervalGraphParent.Interval.Contains(x));

                        // Use similar methods to get the follow lead and follow
                        var followLeadInterval = head.FollowLeader.IntervalGraphParent.Interval;
                        var follow = head.LoopFollow.IntervalGraphParent.Interval.First(x => x.Predecessors.Intersect(followLeadInterval).Count() > 0);
                        var followLead = follow.Predecessors.First(x => followLeadInterval.Contains(x));
                        head.IntervalGraphParent.LoopLatch = parentLatch;
                        head.IntervalGraphParent.LoopFollow = follow;
                        head.IntervalGraphParent.FollowLeader = followLead;
                        head.IntervalGraphParent.LoopType = head.LoopType;
                    }
                }
            }

            // Now move the head graph onto the real control flow graph
            foreach (var node in headGraph.Nodes)
            {
                if (node.LoopLatch != null)
                {
                    var b = node.OriginalBlock;
                    b.LoopLatch = node.LoopLatch.OriginalBlock;
                    b.LoopLatch.IsLoopLatch = true;
                    b.LoopFollow = node.LoopFollow.OriginalBlock;
                }
            }
        }

        /*public void DetectTwoWayConditionals()
        {
            var unresolved = new HashSet<CFG.BasicBlock>();
            var order = PostorderTraversal(false);
            foreach (var node in PostorderTraversal(false))
            {
                if (node.BlockID == 30)
                {
                    Console.WriteLine("boo");
                }
                if (node.Successors.Count() == 2 && node.Instructions.Last() is Jump jmp)
                {
                    int maxEdges = 0;
                    CFG.BasicBlock maxNode = null;
                    foreach (var d in node.DominanceTreeSuccessors)
                    {
                        if (d.Predecessors.Count() >= 2 && d.Predecessors.Count() > maxEdges)
                        {
                            maxEdges = d.Predecessors.Count();
                            maxNode = d;
                        }
                    }
                    if (maxNode != null)
                    {
                        if (maxNode.BlockID == 30)
                        {
                            Console.WriteLine("boo");
                        }
                        node.Follow = maxNode;
                        bool keepMN = false;
                        var unresolvedClone = new HashSet<CFG.BasicBlock>(unresolved);
                        foreach (var x in unresolvedClone)
                        {
                            if (x != maxNode)
                            {
                                bool inc = (x.DominanceTreeSuccessors.Count() == 0);
                                foreach (var domsucc in x.DominanceTreeSuccessors)
                                {
                                    if (domsucc.Successors.Contains(maxNode))
                                    {
                                        inc = true;
                                    }
                                }
                                if (inc)
                                {
                                    x.Follow = maxNode;
                                    unresolved.Remove(x);
                                }
                            }
                        }
                        
                    }
                    else
                    {
                        unresolved.Add(node);
                    }
                }
            }
        }*/

        public void DetectTwoWayConditionals()
        {
            var debugVisited = new HashSet<CFG.BasicBlock>();
            HashSet<CFG.BasicBlock> Visit(CFG.BasicBlock b)
            {
                if (b.BlockID == 11)
                {
                    //Console.WriteLine("Hi");
                }
                var unresolved = new HashSet<CFG.BasicBlock>();
                foreach (var succ in b.DominanceTreeSuccessors)
                {
                    if (debugVisited.Contains(succ))
                    {
                        throw new Exception("Revisited dom tree node " + succ);
                    }
                    debugVisited.Add(succ);
                    unresolved.UnionWith(Visit(succ));
                }

                if (b.Successors.Count() == 2 && b.Instructions.Last() is Jump jmp && !b.IsLoopHead)
                {
                    int maxEdges = 0;
                    CFG.BasicBlock maxNode = null;
                    foreach (var d in b.DominanceTreeSuccessors)
                    {
                        int successorsReq = 2;
                        // If there is a break or while, the follow node is only going to have one backedge
                        if (b.LoopBreakFollow != null || b.LoopContinueFollow != null)
                        {
                            successorsReq = 1;
                        }
                        if (d.Predecessors.Count() >= successorsReq && d.Predecessors.Count() > maxEdges && !d.IsContinueNode && !d.IsBreakNode && d != EndBlock)
                        {
                            maxEdges = d.Predecessors.Count();
                            maxNode = d;
                        }
                    }
                    // Heuristic: if the true branch leads to a return or is if-orphaned and the follow isn't defined already, then the follow is always the false branch
                    if (maxNode == null && (b.Successors[0].Instructions.Last() is Return || b.Successors[0].IfOrphaned))
                    {
                        // If the false branch leads to an isolated return node or an if-orphaned node, then we are if-orphaned, which essentially means we don't
                        // have a follow defined in the CFG. This means that to structure this, the if-orphaned node must be adopted by the next node with a CFG
                        // determined follow and this node will inherit that follow
                        if ((b.Successors[1].Instructions.Last() is Return && b.Successors[1].Predecessors.Count() == 1) || b.Successors[1].IfOrphaned)
                        {
                            b.IfOrphaned = true;
                        }
                        else
                        {
                            maxNode = b.Successors[1];
                        }
                    }
                    if (maxNode != null)
                    {
                        b.Follow = maxNode;
                        bool keepMN = false;
                        var unresolvedClone = new HashSet<CFG.BasicBlock>(unresolved);
                        foreach (var x in unresolvedClone)
                        {
                            if (x != maxNode)
                            {
                                bool inc = (x.DominanceTreeSuccessors.Count() == 0);
                                // Do a BFS down the dominance heirarchy to search for a follow
                                var bfsQueue = new Queue<CFG.BasicBlock>(x.DominanceTreeSuccessors);
                                //foreach (var domsucc in x.DominanceTreeSuccessors)
                                //{
                                while (bfsQueue.Count() > 0)
                                {
                                    var domsucc = bfsQueue.Dequeue();
                                    if (domsucc.Successors.Contains(maxNode) || domsucc.Follow == maxNode)
                                    {
                                        inc = true;
                                        break;
                                    }
                                    domsucc.Successors.ForEach(s => bfsQueue.Enqueue(s));
                                }
                                //}
                                if (x.IfOrphaned)
                                {
                                    inc = true;
                                }
                                if (inc)
                                {
                                    x.Follow = maxNode;
                                    unresolved.Remove(x);
                                }
                            }
                        }

                    }
                    else
                    {
                        unresolved.Add(b);
                    }
                }

                // The loop head is the implicit follow of any unmatched conditionals
                if (b.IsLoopHead)
                {
                    foreach (var ur in unresolved)
                    {
                        ur.Follow = b;
                    }
                    unresolved.Clear();
                }

                return unresolved;
            }

            Visit(BeginBlock);
        }

        /// <summary>
        /// If conditional structuring won't detect if statements that lead to a break or continue. This pass aims to identify and structure those
        /// </summary>
        public void DetectLoopConditionals()
        {
            var visited = new HashSet<CFG.BasicBlock>();
            void Visit(CFG.BasicBlock b, CFG.BasicBlock loopHead)
            {
                visited.Add(b);
                var lhead = loopHead;
                if (b.IsLoopHead)
                {
                    lhead = b;
                }
                foreach (var succ in b.Successors)
                {
                    if (!visited.Contains(succ))
                    {
                        Visit(succ, lhead);
                    }
                }

                // Detect unstructured if statements
                if (lhead != null && b.Successors.Count() == 2 && b.Instructions.Last() is Jump jmp && !(b.IsLoopHead && b.LoopType == CFG.LoopType.LoopPretested))
                {
                    // An if statement is unstructured but recoverable if it has a forward edge to the loop follow (break) or head (continue) on the left or right
                    bool isBreak = false;
                    bool isContinue = false;
                    foreach (var succ in b.DominanceTreeSuccessors)
                    {
                        // Mark breaks
                        if (succ.Successors.Contains(lhead.LoopFollow))
                        {
                            succ.IsBreakNode = true;
                            b.LoopBreakFollow = lhead.LoopFollow;
                        }
                        // Mark continues
                        if (succ.Successors.Contains(lhead))
                        {
                            succ.IsContinueNode = true;
                            b.LoopContinueFollow = lhead.LoopContinueFollow;
                        }
                    }
                }
            }
            Visit(BeginBlock, null);
        }

        public void StructureCompoundConditionals()
        {
            bool changed = true;
            while (changed)
            {
                changed = false;
                NumberReversePostorder();
                foreach (var node in PostorderTraversal(false))
                {
                    if (node.Successors.Count() == 2 && node.Instructions.Last() is Jump n)
                    {
                        var t = node.Successors[0];
                        var e = node.Successors[1];
                        if (t.Successors.Count() == 2 && t.Instructions.First() is Jump tj && t.Predecessors.Count() == 1)
                        {
                            if (t.Successors[0] == e)
                            {
                                var newCond = new BinOp(n.Condition, new UnaryOp(tj.Condition, UnaryOp.OperationType.OpNot), BinOp.OperationType.OpAnd);
                                n.Condition = newCond;
                                if (t.Follow != null)
                                {
                                    node.Follow = (node.Follow.ReversePostorderNumber > t.Follow.ReversePostorderNumber) ? node.Follow : t.Follow;
                                }
                                node.Successors[0] = t.Successors[1];
                                var i = t.Successors[1].Predecessors.IndexOf(t);
                                t.Successors[1].Predecessors[i] = node;
                                e.Predecessors.Remove(t);
                                BlockList.Remove(t);
                                changed = true;
                            }
                            else if (t.Successors[1] == e)
                            {
                                var newCond = new BinOp(n.Condition, tj.Condition, BinOp.OperationType.OpAnd);
                                n.Condition = newCond;
                                if (t.Follow != null)
                                {
                                    node.Follow = (node.Follow.ReversePostorderNumber > t.Follow.ReversePostorderNumber) ? node.Follow : t.Follow;
                                }
                                node.Successors[0] = t.Successors[0];
                                var i = t.Successors[0].Predecessors.IndexOf(t);
                                t.Successors[0].Predecessors[i] = node;
                                e.Predecessors.Remove(t);
                                BlockList.Remove(t);
                                changed = true;
                            }
                        }
                        else if (e.Successors.Count() == 2 && e.Instructions.First() is Jump ej && e.Predecessors.Count() == 1)
                        {
                            if (e.Successors[0] == t)
                            {
                                var newCond = new BinOp(new UnaryOp(n.Condition, UnaryOp.OperationType.OpNot), ej.Condition, BinOp.OperationType.OpOr);
                                n.Condition = newCond;
                                if (e.Follow != null)
                                {
                                    node.Follow = (node.Follow.ReversePostorderNumber > e.Follow.ReversePostorderNumber) ? node.Follow : e.Follow;
                                }
                                node.Successors[1] = e.Successors[1];
                                var i = e.Successors[1].Predecessors.IndexOf(e);
                                e.Successors[1].Predecessors[i] = node;
                                t.Predecessors.Remove(e);
                                BlockList.Remove(e);
                                changed = true;
                            }
                            else if (e.Successors[1] == t)
                            {
                                var newCond = new BinOp(n.Condition, ej.Condition, BinOp.OperationType.OpOr);
                                n.Condition = newCond;
                                if (e.Follow != null)
                                {
                                    node.Follow = (node.Follow.ReversePostorderNumber > e.Follow.ReversePostorderNumber) ? node.Follow : e.Follow;
                                }
                                node.Successors[1] = e.Successors[0];
                                var i = e.Successors[0].Predecessors.IndexOf(e);
                                e.Successors[0].Predecessors[i] = node;
                                t.Predecessors.Remove(e);
                                BlockList.Remove(e);
                                changed = true;
                            }
                        }
                    }
                }
            }
            ComputeDominance();
        }

        /// <summary>
        /// Naive method to convert out of SSA. Not guaranteed to produce correct code since no liveness/interferance analysis is done
        /// </summary>
        public void DropSSANaive()
        {
            // Do a postorder traversal down the CFG and use the phi functions to create a map of renamings
            HashSet<CFG.BasicBlock> visited = new HashSet<CFG.BasicBlock>();
            HashSet<CFG.BasicBlock> processed = new HashSet<CFG.BasicBlock>();

            // This is used to propogate replacements induced by a loop latch down a dominance heirarchy 
            void BackPropogate(CFG.BasicBlock b, Dictionary<Identifier, Identifier> inReplacements)
            {
                // Rename variables in the block by traversing in reverse order
                for (int i = b.Instructions.Count() - 1; i >= 0; i--)
                {
                    var inst = b.Instructions[i];
                    var defs = inst.GetDefines(true);
                    foreach (var def in defs)
                    {
                        if (inReplacements.ContainsKey(def))
                        {
                            inst.RenameDefines(def, inReplacements[def]);
                            inReplacements.Remove(def);
                        }
                    }
                    foreach (var use in inst.GetUses(true))
                    {
                        if (inReplacements.ContainsKey(use))
                        {
                            inst.RenameUses(use, inReplacements[use]);
                        }
                    }
                }

                foreach (var succ in b.DominanceTreeSuccessors)
                {
                    BackPropogate(succ, inReplacements);
                }
            }

            Dictionary<Identifier, Identifier> Visit(CFG.BasicBlock b)
            {
                visited.Add(b);
                // A set of mappings to rename variables induced by phi functions
                var replacements = new Dictionary<Identifier, Identifier>();
                foreach (var succ in b.Successors)
                {
                    if (!visited.Contains(succ))
                    {
                        var previsited = Visit(succ);
                        foreach (var rep in previsited)
                        {
                            if (!replacements.ContainsKey(rep.Key))
                            {
                                replacements.Add(rep.Key, rep.Value);
                            }
                        }
                    }
                }
                

                // First rename and delete phi functions by renaming the arguments to the assignment
                var phiuses = new HashSet<Identifier>();
                foreach (var phi in b.PhiFunctions)
                {
                    var def = phi.Value.Left;
                    foreach (var use in phi.Value.Right)
                    {
                        phiuses.Add(use);
                        if (replacements.ContainsKey(use))
                        {
                            if (replacements[use] != def)
                            {
                                throw new Exception("Conflicting phi function renames live at the same time");
                            }
                        }
                        else
                        {
                            replacements.Add(use, def);
                        }
                    }
                }
                b.PhiFunctions.Clear();

                // Rename variables in the block by traversing in reverse order
                for (int i = b.Instructions.Count() - 1; i >= 0; i--)
                {
                    var inst = b.Instructions[i];
                    var defs = inst.GetDefines(true);
                    foreach (var def in defs)
                    {
                        if (replacements.ContainsKey(def))
                        {
                            inst.RenameDefines(def, replacements[def]);
                            // Only retire this replacement if it wasn't used by a phi function in this block
                            if (!phiuses.Contains(def))
                            {
                                replacements.Remove(def);
                            }
                        }
                    }
                    foreach (var use in inst.GetUses(true))
                    {
                        if (replacements.ContainsKey(use))
                        {
                            inst.RenameUses(use, replacements[use]);
                        }
                    }
                }
                processed.Add(b);

                // Propogate the replacements to children if this is a latch (i.e. induces a loop) and the head was already processed
                foreach (var succ in b.Successors)
                {
                    if (processed.Contains(succ))
                    {
                        BackPropogate(succ, replacements);
                    }
                }
                

                return replacements;
            }

            Visit(BeginBlock);
        }

        public void ConvertToAST()
        {
            // Traverse all the nodes in post-order and try to convert jumps to if statements
            var usedFollows = new HashSet<CFG.BasicBlock>();

            // Step 1: build the AST for ifs/loops based on follow information
            foreach (var node in PostorderTraversal(true))
            {
                // A for loop is a pretested loop where the follow does not match the head
                if (node.LoopFollow != null && node.LoopFollow != node && node.Predecessors.Count() == 2 && node.LoopType == CFG.LoopType.LoopPretested)
                {
                    var loopInitializer = node.Predecessors.First(x => x != node.LoopLatch);
                    if (node.Instructions.Last() is Jump loopJump && loopJump.Condition is BinOp loopCondition && loopCondition.Operation == BinOp.OperationType.OpLoopCompare)
                    {
                        var nfor = new NumericFor();
                        nfor.Limit = loopCondition.Right;
                        Identifier loopvar = (loopCondition.Left as IdentifierReference).Identifier;
                        var incinst = node.Instructions[node.Instructions.Count() - 2];
                        nfor.Increment = ((incinst as Assignment).Right as BinOp).Right;

                        // Search the predecessor block for the initial assignment (i.e. the definition)
                        for (int i = loopInitializer.Instructions.Count() - 1; i >= 0; i--)
                        {
                            if (loopInitializer.Instructions[i] is Assignment a && a.GetDefines(true).Contains(loopvar))
                            {
                                nfor.Initial = a;
                                loopInitializer.Instructions.RemoveAt(i);
                                break;
                            }
                        }
                        nfor.Body = node.Successors[1];
                        nfor.Body.MarkCodegened(DebugID);
                        nfor.Follow = node.LoopFollow;
                        loopInitializer.Instructions[loopInitializer.Instructions.Count() - 1] = nfor;
                    }
                }

                // Pattern match for an if statement
                if (node.Follow != null && node.Instructions.Last() is Jump jmp)
                {
                    var ifStatement = new IfStatement();
                    ifStatement.Condition = jmp.Condition;
                    ifStatement.True = node.Successors[0];
                    ifStatement.True.MarkCodegened(DebugID);
                    if (ifStatement.True.Instructions.Last() is Jump lj && !lj.Conditional)
                    {
                        if (ifStatement.True.IsBreakNode)
                        {
                            ifStatement.True.Instructions[ifStatement.True.Instructions.Count() - 1] = new Break();
                        }
                        else
                        {
                            ifStatement.True.Instructions.Remove(lj);
                        }
                    }
                    if (node.Successors[1] != node.Follow)
                    {

                        ifStatement.False = node.Successors[1];
                        ifStatement.False.MarkCodegened(DebugID);
                        if (ifStatement.False.Instructions.Last() is Jump fj && !fj.Conditional)
                        {
                            if (ifStatement.False.IsBreakNode)
                            {
                                ifStatement.False.Instructions[ifStatement.False.Instructions.Count() - 1] = new Break();
                            }
                            else
                            {
                                ifStatement.False.Instructions.Remove(fj);
                            }
                        }

                    }
                    if (!usedFollows.Contains(node.Follow))
                    {
                        ifStatement.Follow = node.Follow;
                        ifStatement.Follow.MarkCodegened(DebugID);
                        usedFollows.Add(node.Follow);
                    }
                    node.Instructions[node.Instructions.Count() - 1] = ifStatement;
                }
            }

            // Step 2: Remove Jmp instructions from follows if they exist
            foreach (var follow in usedFollows)
            {
                if (follow.Instructions.Count() > 0 && follow.Instructions.Last() is Jump jmp)
                {
                    follow.Instructions.Remove(jmp);
                }
            }

            IsAST = true;
        }

        // Rename variables from their temporary register based names to something more generic
        public void RenameVariables()
        {
            HashSet<Identifier> renamed = new HashSet<Identifier>();

            // Rename function arguments
            for (int i = 0; i < Parameters.Count(); i++)
            {
                renamed.Add(Parameters[i]);
                Parameters[i].Name = $@"arg{i}";
            }

            // Rename all the locals
            int localCounter = 0;
            foreach (var b in BlockList)
            {
                foreach (var i in b.Instructions)
                {
                    if (i is Assignment a)
                    {
                        foreach (var l in a.Left)
                        {
                            if (l is IdentifierReference ir && !ir.HasIndex && ir.Identifier.IType == Identifier.IdentifierType.Register && !renamed.Contains(ir.Identifier))
                            {
                                renamed.Add(l.Identifier);
                                ir.Identifier.Name = $@"local{localCounter}";
                                localCounter++;
                            }
                        }
                    }
                }
            }
        }

        public override string ToString()
        {
            //string str = $@"function {DebugID} (";
            string str = $@"function (";
            for (int i = 0; i < Parameters.Count(); i++)
            {
                str += Parameters[i].ToString();
                if (i != Parameters.Count() - 1)
                {
                    str += ", ";
                }
            }
            str += ")\n";
            IndentLevel += 1;
            if (!IsControlFlowGraph)
            {
                foreach (var inst in Instructions)
                {
                    for (int i = 0; i < IndentLevel; i++)
                    {
                        if (inst is Label && i == IndentLevel - 1)
                        {
                            str += "  ";
                            continue;
                        }
                        str += "    ";
                    }
                    str += inst.ToString() + "\n";
                }
            }
            else if (IsAST)
            {
                str += BeginBlock.PrintBlock(IndentLevel);
                str += "\n";
            }
            else
            {
                // Traverse the basic blocks odereded by their ID
                foreach (var b in BlockList.OrderBy(a => a.BlockID))
                {
                    if (b == EndBlock)
                    {
                        continue;
                    }
                    for (int i = 0; i < IndentLevel; i++)
                    {
                        if (i == IndentLevel - 1)
                        {
                            str += "  ";
                            continue;
                        }
                        str += "    ";
                    }
                    str += b.ToStringWithLoop() + "\n";
                    foreach (var inst in b.PhiFunctions.Values)
                    {
                        for (int i = 0; i < IndentLevel; i++)
                        {
                            str += "    ";
                        }
                        str += inst.ToString() + "\n";
                    }
                    foreach (var inst in b.Instructions)
                    {
                        for (int i = 0; i < IndentLevel; i++)
                        {
                            str += "    ";
                        }
                        str += inst.ToString() + "\n";
                    }
                }
            }
            IndentLevel -= 1;
            for (int i = 0; i < IndentLevel; i++)
            {
                str += "    ";
            }
            str += "end";
            return str;
        }
    }
}
